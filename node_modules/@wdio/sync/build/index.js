"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "executeHooksWithArgs", {
  enumerable: true,
  get: function () {
    return _executeHooksWithArgs.default;
  }
});
Object.defineProperty(exports, "runFnInFiberContext", {
  enumerable: true,
  get: function () {
    return _runFnInFiberContext.default;
  }
});
Object.defineProperty(exports, "runFnInFiberContextWithCallback", {
  enumerable: true,
  get: function () {
    return _runFnInFiberContextWithCallback.default;
  }
});
Object.defineProperty(exports, "wrapCommand", {
  enumerable: true,
  get: function () {
    return _wrapCommand.default;
  }
});
exports.executeAsync = exports.executeSync = exports.runTestInFiberContext = void 0;

var _fibers = _interopRequireDefault(require("fibers"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _executeHooksWithArgs = _interopRequireDefault(require("./executeHooksWithArgs"));

var _runFnInFiberContext = _interopRequireDefault(require("./runFnInFiberContext"));

var _runFnInFiberContextWithCallback = _interopRequireDefault(require("./runFnInFiberContextWithCallback"));

var _wrapCommand = _interopRequireDefault(require("./wrapCommand"));

var _constants = require("./constants");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('@wdio/sync');

const executeSync = function (fn, repeatTest = 0, args = []) {
  return new Promise((resolve, reject) => {
    try {
      const res = fn.apply(this, args);
      resolve(res);
    } catch (e) {
      if (repeatTest) {
        return resolve(executeSync(fn, --repeatTest, args));
      }

      if (!e.stack) {
        return reject(e);
      }

      e.stack = e.stack.split('\n').filter(_constants.STACKTRACE_FILTER_FN).join('\n');
      reject(e);
    }
  });
};

exports.executeSync = executeSync;

const executeAsync = function (fn, repeatTest = 0, args = []) {
  let result, error;

  try {
    result = fn.apply(this, args);
  } catch (e) {
    error = e;
  }

  if (error) {
    if (repeatTest) {
      return executeAsync(fn, --repeatTest, args);
    }

    return new Promise((resolve, reject) => reject(error));
  }

  if (repeatTest === 0 || !result || typeof result.catch !== 'function') {
    return new Promise(resolve => resolve(result));
  }

  return result.catch(e => {
    if (repeatTest) {
      return executeAsync(fn, --repeatTest, args);
    }

    e.stack = e.stack.split('\n').filter(_constants.STACKTRACE_FILTER_FN).join('\n');
    return Promise.reject(e);
  });
};

exports.executeAsync = executeAsync;

const runHook = function (hookFn, origFn, before, after, repeatTest = 0) {
  const hookError = hookName => e => log.error(`Error in ${hookName}: ${e.stack}`);

  return origFn(function (...hookArgs) {
    return (0, _executeHooksWithArgs.default)(before).catch(hookError('beforeHook')).then(() => {
      if (hookFn.constructor && hookFn.constructor.name === 'AsyncFunction' || hookFn.name === 'async') {
        return executeAsync.call(this, hookFn, repeatTest, (0, _utils.filterSpecArgs)(hookArgs));
      }

      return new Promise(runSync.call(this, hookFn, repeatTest, (0, _utils.filterSpecArgs)(hookArgs)));
    }).then(() => {
      return (0, _executeHooksWithArgs.default)(after).catch(hookError('afterHook'));
    });
  });
};

const runSpec = function (specTitle, specFn, origFn, repeatTest = 0) {
  if (specFn.constructor && specFn.constructor.name === 'AsyncFunction' || specFn.name === 'async') {
    return origFn(specTitle, function async(...specArgs) {
      return executeAsync.call(this, specFn, repeatTest, (0, _utils.filterSpecArgs)(specArgs));
    });
  }

  return origFn(specTitle, function (...specArgs) {
    return new Promise(runSync.call(this, specFn, repeatTest, (0, _utils.filterSpecArgs)(specArgs)));
  });
};

function runSync(fn, repeatTest = 0, args = []) {
  return (resolve, reject) => (0, _fibers.default)(() => executeSync.call(this, fn, repeatTest, args).then(() => resolve(), reject)).run();
}

const wrapTestFunction = function (fnName, origFn, testInterfaceFnNames, before, after) {
  return function (...specArguments) {
    let retryCnt = typeof specArguments[specArguments.length - 1] === 'number' ? specArguments.pop() : 0;
    const specFn = typeof specArguments[0] === 'function' ? specArguments.shift() : typeof specArguments[1] === 'function' ? specArguments.pop() : undefined;
    const specTitle = specArguments[0];

    if (testInterfaceFnNames.indexOf(fnName) > -1) {
      if (specFn) return runSpec(specTitle, specFn, origFn, retryCnt);
      return origFn(specTitle);
    }

    return runHook(specFn, origFn, before, after, retryCnt);
  };
};

const runTestInFiberContext = function (testInterfaceFnNames, before, after, fnName, scope = global) {
  const origFn = scope[fnName];
  scope[fnName] = wrapTestFunction(fnName, origFn, testInterfaceFnNames, before, after);

  if (typeof origFn.skip === 'function') {
    scope[fnName].skip = origFn.skip;
  }

  if (typeof origFn.only === 'function') {
    const origOnlyFn = origFn.only;
    scope[fnName].only = wrapTestFunction(fnName + '.only', origOnlyFn, testInterfaceFnNames, before, after);
  }
};

exports.runTestInFiberContext = runTestInFiberContext;