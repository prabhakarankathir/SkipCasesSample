"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = wrapCommand;

var _future = _interopRequireDefault(require("fibers/future"));

var _executeHooksWithArgs = _interopRequireDefault(require("./executeHooksWithArgs"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function wrapCommand(commandName, fn) {
  return function wrapCommandFn(...args) {
    const stackError = new Error();

    if (this._NOT_FIBER === true) {
      this._NOT_FIBER = isNotInFiber(this, fn.name);
      return runCommand.apply(this, [fn, stackError, ...args]);
    }

    this._NOT_FIBER = fn.name !== '' && fn.name !== 'debug' && commandName !== 'waitUntil';
    const future = new _future.default();
    const result = runCommandWithHooks.apply(this, [commandName, fn, stackError, ...args]);
    result.then(future.return.bind(future), future.throw.bind(future));

    try {
      const futureResult = future.wait();
      inFiber(this);
      return futureResult;
    } catch (e) {
      if (typeof e === 'string') {
        throw new Error(e);
      }

      if (e.message.includes('Can\'t wait without a fiber')) {
        return result;
      }

      inFiber(this);
      throw e;
    }
  };
}

async function runCommandWithHooks(commandName, fn, stackError, ...args) {
  await (0, _executeHooksWithArgs.default)(this.options.beforeCommand, [commandName, args]);
  let commandResult;
  let commandError;

  try {
    commandResult = await runCommand.apply(this, [fn, stackError, ...args]);
  } catch (err) {
    commandError = err;
  }

  await (0, _executeHooksWithArgs.default)(this.options.afterCommand, [commandName, args, commandResult, commandError]);

  if (commandError) {
    throw commandError;
  }

  return commandResult;
}

async function runCommand(fn, stackError, ...args) {
  try {
    return await fn.apply(this, args);
  } catch (err) {
    throw (0, _utils.sanitizeErrorMessage)(err, stackError);
  }
}

function isNotInFiber(context, fnName) {
  return fnName !== '' && !!(context.elementId || context.parent && context.parent.elementId);
}

function inFiber(context) {
  context._NOT_FIBER = false;
  let parent = context.parent;

  while (parent && parent._NOT_FIBER) {
    parent._NOT_FIBER = false;
    parent = parent.parent;
  }
}